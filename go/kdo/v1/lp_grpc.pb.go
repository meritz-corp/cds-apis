// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: kdo/v1/lp.proto

package kdo

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LpServiceClient is the client API for LpService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LpServiceClient interface {
	// ETF LP 조회
	GetEtfLp(ctx context.Context, in *GetEtfLpRequest, opts ...grpc.CallOption) (*EtfLp, error)
	// ETF LP 조회
	ListEtfLps(ctx context.Context, in *ListEtfLpsRequest, opts ...grpc.CallOption) (*ListEtfLpsResponse, error)
	// ETF LP 업데이트
	UpdateEtfLp(ctx context.Context, in *UpdateEtfLpRequest, opts ...grpc.CallOption) (*EtfLp, error)
	// ETF LP 상태 조회
	GetEtfLpStatus(ctx context.Context, in *GetEtfLpStatusRequest, opts ...grpc.CallOption) (*EtfLpStatus, error)
	// ETF LP 상태 스트리밍 (실시간 업데이트)
	StreamEtfLpStatus(ctx context.Context, in *StreamEtfLpStatusRequest, opts ...grpc.CallOption) (LpService_StreamEtfLpStatusClient, error)
	// ETF LP 시작
	StartEtfLp(ctx context.Context, in *StartEtfLpRequest, opts ...grpc.CallOption) (*StartEtfLpResponse, error)
	// ETF LP 중지
	StopEtfLp(ctx context.Context, in *StopEtfLpRequest, opts ...grpc.CallOption) (*StopEtfLpResponse, error)
	// ETF LP 에러 이벤트 실시간 스트리밍
	StreamEtfErrors(ctx context.Context, in *StreamEtfErrorsRequest, opts ...grpc.CallOption) (LpService_StreamEtfErrorsClient, error)
	// 사용자 주문장 업데이트를 가져오기
	GetUserOrderbook(ctx context.Context, in *GetUserOrderBookRequest, opts ...grpc.CallOption) (*UserOrderbookData, error)
	// 사용자 주문장 업데이트를 스트리밍
	StreamUserOrderbook(ctx context.Context, in *GetUserOrderBookRequest, opts ...grpc.CallOption) (LpService_StreamUserOrderbookClient, error)
}

type lpServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLpServiceClient(cc grpc.ClientConnInterface) LpServiceClient {
	return &lpServiceClient{cc}
}

func (c *lpServiceClient) GetEtfLp(ctx context.Context, in *GetEtfLpRequest, opts ...grpc.CallOption) (*EtfLp, error) {
	out := new(EtfLp)
	err := c.cc.Invoke(ctx, "/kdo.v1.lp.LpService/GetEtfLp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lpServiceClient) ListEtfLps(ctx context.Context, in *ListEtfLpsRequest, opts ...grpc.CallOption) (*ListEtfLpsResponse, error) {
	out := new(ListEtfLpsResponse)
	err := c.cc.Invoke(ctx, "/kdo.v1.lp.LpService/ListEtfLps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lpServiceClient) UpdateEtfLp(ctx context.Context, in *UpdateEtfLpRequest, opts ...grpc.CallOption) (*EtfLp, error) {
	out := new(EtfLp)
	err := c.cc.Invoke(ctx, "/kdo.v1.lp.LpService/UpdateEtfLp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lpServiceClient) GetEtfLpStatus(ctx context.Context, in *GetEtfLpStatusRequest, opts ...grpc.CallOption) (*EtfLpStatus, error) {
	out := new(EtfLpStatus)
	err := c.cc.Invoke(ctx, "/kdo.v1.lp.LpService/GetEtfLpStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lpServiceClient) StreamEtfLpStatus(ctx context.Context, in *StreamEtfLpStatusRequest, opts ...grpc.CallOption) (LpService_StreamEtfLpStatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &LpService_ServiceDesc.Streams[0], "/kdo.v1.lp.LpService/StreamEtfLpStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &lpServiceStreamEtfLpStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LpService_StreamEtfLpStatusClient interface {
	Recv() (*EtfLpStatus, error)
	grpc.ClientStream
}

type lpServiceStreamEtfLpStatusClient struct {
	grpc.ClientStream
}

func (x *lpServiceStreamEtfLpStatusClient) Recv() (*EtfLpStatus, error) {
	m := new(EtfLpStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lpServiceClient) StartEtfLp(ctx context.Context, in *StartEtfLpRequest, opts ...grpc.CallOption) (*StartEtfLpResponse, error) {
	out := new(StartEtfLpResponse)
	err := c.cc.Invoke(ctx, "/kdo.v1.lp.LpService/StartEtfLp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lpServiceClient) StopEtfLp(ctx context.Context, in *StopEtfLpRequest, opts ...grpc.CallOption) (*StopEtfLpResponse, error) {
	out := new(StopEtfLpResponse)
	err := c.cc.Invoke(ctx, "/kdo.v1.lp.LpService/StopEtfLp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lpServiceClient) StreamEtfErrors(ctx context.Context, in *StreamEtfErrorsRequest, opts ...grpc.CallOption) (LpService_StreamEtfErrorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &LpService_ServiceDesc.Streams[1], "/kdo.v1.lp.LpService/StreamEtfErrors", opts...)
	if err != nil {
		return nil, err
	}
	x := &lpServiceStreamEtfErrorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LpService_StreamEtfErrorsClient interface {
	Recv() (*EtfLpError, error)
	grpc.ClientStream
}

type lpServiceStreamEtfErrorsClient struct {
	grpc.ClientStream
}

func (x *lpServiceStreamEtfErrorsClient) Recv() (*EtfLpError, error) {
	m := new(EtfLpError)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lpServiceClient) GetUserOrderbook(ctx context.Context, in *GetUserOrderBookRequest, opts ...grpc.CallOption) (*UserOrderbookData, error) {
	out := new(UserOrderbookData)
	err := c.cc.Invoke(ctx, "/kdo.v1.lp.LpService/GetUserOrderbook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lpServiceClient) StreamUserOrderbook(ctx context.Context, in *GetUserOrderBookRequest, opts ...grpc.CallOption) (LpService_StreamUserOrderbookClient, error) {
	stream, err := c.cc.NewStream(ctx, &LpService_ServiceDesc.Streams[2], "/kdo.v1.lp.LpService/StreamUserOrderbook", opts...)
	if err != nil {
		return nil, err
	}
	x := &lpServiceStreamUserOrderbookClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LpService_StreamUserOrderbookClient interface {
	Recv() (*UserOrderbookData, error)
	grpc.ClientStream
}

type lpServiceStreamUserOrderbookClient struct {
	grpc.ClientStream
}

func (x *lpServiceStreamUserOrderbookClient) Recv() (*UserOrderbookData, error) {
	m := new(UserOrderbookData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LpServiceServer is the server API for LpService service.
// All implementations must embed UnimplementedLpServiceServer
// for forward compatibility
type LpServiceServer interface {
	// ETF LP 조회
	GetEtfLp(context.Context, *GetEtfLpRequest) (*EtfLp, error)
	// ETF LP 조회
	ListEtfLps(context.Context, *ListEtfLpsRequest) (*ListEtfLpsResponse, error)
	// ETF LP 업데이트
	UpdateEtfLp(context.Context, *UpdateEtfLpRequest) (*EtfLp, error)
	// ETF LP 상태 조회
	GetEtfLpStatus(context.Context, *GetEtfLpStatusRequest) (*EtfLpStatus, error)
	// ETF LP 상태 스트리밍 (실시간 업데이트)
	StreamEtfLpStatus(*StreamEtfLpStatusRequest, LpService_StreamEtfLpStatusServer) error
	// ETF LP 시작
	StartEtfLp(context.Context, *StartEtfLpRequest) (*StartEtfLpResponse, error)
	// ETF LP 중지
	StopEtfLp(context.Context, *StopEtfLpRequest) (*StopEtfLpResponse, error)
	// ETF LP 에러 이벤트 실시간 스트리밍
	StreamEtfErrors(*StreamEtfErrorsRequest, LpService_StreamEtfErrorsServer) error
	// 사용자 주문장 업데이트를 가져오기
	GetUserOrderbook(context.Context, *GetUserOrderBookRequest) (*UserOrderbookData, error)
	// 사용자 주문장 업데이트를 스트리밍
	StreamUserOrderbook(*GetUserOrderBookRequest, LpService_StreamUserOrderbookServer) error
	mustEmbedUnimplementedLpServiceServer()
}

// UnimplementedLpServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLpServiceServer struct {
}

func (UnimplementedLpServiceServer) GetEtfLp(context.Context, *GetEtfLpRequest) (*EtfLp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEtfLp not implemented")
}
func (UnimplementedLpServiceServer) ListEtfLps(context.Context, *ListEtfLpsRequest) (*ListEtfLpsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEtfLps not implemented")
}
func (UnimplementedLpServiceServer) UpdateEtfLp(context.Context, *UpdateEtfLpRequest) (*EtfLp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEtfLp not implemented")
}
func (UnimplementedLpServiceServer) GetEtfLpStatus(context.Context, *GetEtfLpStatusRequest) (*EtfLpStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEtfLpStatus not implemented")
}
func (UnimplementedLpServiceServer) StreamEtfLpStatus(*StreamEtfLpStatusRequest, LpService_StreamEtfLpStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamEtfLpStatus not implemented")
}
func (UnimplementedLpServiceServer) StartEtfLp(context.Context, *StartEtfLpRequest) (*StartEtfLpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartEtfLp not implemented")
}
func (UnimplementedLpServiceServer) StopEtfLp(context.Context, *StopEtfLpRequest) (*StopEtfLpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopEtfLp not implemented")
}
func (UnimplementedLpServiceServer) StreamEtfErrors(*StreamEtfErrorsRequest, LpService_StreamEtfErrorsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamEtfErrors not implemented")
}
func (UnimplementedLpServiceServer) GetUserOrderbook(context.Context, *GetUserOrderBookRequest) (*UserOrderbookData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserOrderbook not implemented")
}
func (UnimplementedLpServiceServer) StreamUserOrderbook(*GetUserOrderBookRequest, LpService_StreamUserOrderbookServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamUserOrderbook not implemented")
}
func (UnimplementedLpServiceServer) mustEmbedUnimplementedLpServiceServer() {}

// UnsafeLpServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LpServiceServer will
// result in compilation errors.
type UnsafeLpServiceServer interface {
	mustEmbedUnimplementedLpServiceServer()
}

func RegisterLpServiceServer(s grpc.ServiceRegistrar, srv LpServiceServer) {
	s.RegisterService(&LpService_ServiceDesc, srv)
}

func _LpService_GetEtfLp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEtfLpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LpServiceServer).GetEtfLp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kdo.v1.lp.LpService/GetEtfLp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LpServiceServer).GetEtfLp(ctx, req.(*GetEtfLpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LpService_ListEtfLps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEtfLpsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LpServiceServer).ListEtfLps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kdo.v1.lp.LpService/ListEtfLps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LpServiceServer).ListEtfLps(ctx, req.(*ListEtfLpsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LpService_UpdateEtfLp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEtfLpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LpServiceServer).UpdateEtfLp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kdo.v1.lp.LpService/UpdateEtfLp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LpServiceServer).UpdateEtfLp(ctx, req.(*UpdateEtfLpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LpService_GetEtfLpStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEtfLpStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LpServiceServer).GetEtfLpStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kdo.v1.lp.LpService/GetEtfLpStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LpServiceServer).GetEtfLpStatus(ctx, req.(*GetEtfLpStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LpService_StreamEtfLpStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamEtfLpStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LpServiceServer).StreamEtfLpStatus(m, &lpServiceStreamEtfLpStatusServer{stream})
}

type LpService_StreamEtfLpStatusServer interface {
	Send(*EtfLpStatus) error
	grpc.ServerStream
}

type lpServiceStreamEtfLpStatusServer struct {
	grpc.ServerStream
}

func (x *lpServiceStreamEtfLpStatusServer) Send(m *EtfLpStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _LpService_StartEtfLp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartEtfLpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LpServiceServer).StartEtfLp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kdo.v1.lp.LpService/StartEtfLp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LpServiceServer).StartEtfLp(ctx, req.(*StartEtfLpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LpService_StopEtfLp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopEtfLpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LpServiceServer).StopEtfLp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kdo.v1.lp.LpService/StopEtfLp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LpServiceServer).StopEtfLp(ctx, req.(*StopEtfLpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LpService_StreamEtfErrors_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamEtfErrorsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LpServiceServer).StreamEtfErrors(m, &lpServiceStreamEtfErrorsServer{stream})
}

type LpService_StreamEtfErrorsServer interface {
	Send(*EtfLpError) error
	grpc.ServerStream
}

type lpServiceStreamEtfErrorsServer struct {
	grpc.ServerStream
}

func (x *lpServiceStreamEtfErrorsServer) Send(m *EtfLpError) error {
	return x.ServerStream.SendMsg(m)
}

func _LpService_GetUserOrderbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserOrderBookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LpServiceServer).GetUserOrderbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kdo.v1.lp.LpService/GetUserOrderbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LpServiceServer).GetUserOrderbook(ctx, req.(*GetUserOrderBookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LpService_StreamUserOrderbook_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetUserOrderBookRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LpServiceServer).StreamUserOrderbook(m, &lpServiceStreamUserOrderbookServer{stream})
}

type LpService_StreamUserOrderbookServer interface {
	Send(*UserOrderbookData) error
	grpc.ServerStream
}

type lpServiceStreamUserOrderbookServer struct {
	grpc.ServerStream
}

func (x *lpServiceStreamUserOrderbookServer) Send(m *UserOrderbookData) error {
	return x.ServerStream.SendMsg(m)
}

// LpService_ServiceDesc is the grpc.ServiceDesc for LpService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LpService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kdo.v1.lp.LpService",
	HandlerType: (*LpServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEtfLp",
			Handler:    _LpService_GetEtfLp_Handler,
		},
		{
			MethodName: "ListEtfLps",
			Handler:    _LpService_ListEtfLps_Handler,
		},
		{
			MethodName: "UpdateEtfLp",
			Handler:    _LpService_UpdateEtfLp_Handler,
		},
		{
			MethodName: "GetEtfLpStatus",
			Handler:    _LpService_GetEtfLpStatus_Handler,
		},
		{
			MethodName: "StartEtfLp",
			Handler:    _LpService_StartEtfLp_Handler,
		},
		{
			MethodName: "StopEtfLp",
			Handler:    _LpService_StopEtfLp_Handler,
		},
		{
			MethodName: "GetUserOrderbook",
			Handler:    _LpService_GetUserOrderbook_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamEtfLpStatus",
			Handler:       _LpService_StreamEtfLpStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamEtfErrors",
			Handler:       _LpService_StreamEtfErrors_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamUserOrderbook",
			Handler:       _LpService_StreamUserOrderbook_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "kdo/v1/lp.proto",
}
