// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: market_archive/v1/market.proto

package market_archive

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// OrderbookServiceClient is the client API for OrderbookService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrderbookServiceClient interface {
	// 호가 이력 조회
	GetOrderbooks(ctx context.Context, in *GetOrderbooksRequest, opts ...grpc.CallOption) (*GetOrderbooksResponse, error)
	// 최신 호가 조회
	GetLatestOrderbook(ctx context.Context, in *GetLatestOrderbookRequest, opts ...grpc.CallOption) (*Orderbook, error)
	// 특정 시점 스냅샷
	GetOrderbookSnapshot(ctx context.Context, in *GetOrderbookSnapshotRequest, opts ...grpc.CallOption) (*Orderbook, error)
	// 실시간 호가 스트림
	SubscribeOrderbooks(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (OrderbookService_SubscribeOrderbooksClient, error)
}

type orderbookServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOrderbookServiceClient(cc grpc.ClientConnInterface) OrderbookServiceClient {
	return &orderbookServiceClient{cc}
}

func (c *orderbookServiceClient) GetOrderbooks(ctx context.Context, in *GetOrderbooksRequest, opts ...grpc.CallOption) (*GetOrderbooksResponse, error) {
	out := new(GetOrderbooksResponse)
	err := c.cc.Invoke(ctx, "/market_archive.v1.market.OrderbookService/GetOrderbooks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderbookServiceClient) GetLatestOrderbook(ctx context.Context, in *GetLatestOrderbookRequest, opts ...grpc.CallOption) (*Orderbook, error) {
	out := new(Orderbook)
	err := c.cc.Invoke(ctx, "/market_archive.v1.market.OrderbookService/GetLatestOrderbook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderbookServiceClient) GetOrderbookSnapshot(ctx context.Context, in *GetOrderbookSnapshotRequest, opts ...grpc.CallOption) (*Orderbook, error) {
	out := new(Orderbook)
	err := c.cc.Invoke(ctx, "/market_archive.v1.market.OrderbookService/GetOrderbookSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderbookServiceClient) SubscribeOrderbooks(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (OrderbookService_SubscribeOrderbooksClient, error) {
	stream, err := c.cc.NewStream(ctx, &OrderbookService_ServiceDesc.Streams[0], "/market_archive.v1.market.OrderbookService/SubscribeOrderbooks", opts...)
	if err != nil {
		return nil, err
	}
	x := &orderbookServiceSubscribeOrderbooksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrderbookService_SubscribeOrderbooksClient interface {
	Recv() (*OrderbookUpdate, error)
	grpc.ClientStream
}

type orderbookServiceSubscribeOrderbooksClient struct {
	grpc.ClientStream
}

func (x *orderbookServiceSubscribeOrderbooksClient) Recv() (*OrderbookUpdate, error) {
	m := new(OrderbookUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// OrderbookServiceServer is the server API for OrderbookService service.
// All implementations must embed UnimplementedOrderbookServiceServer
// for forward compatibility
type OrderbookServiceServer interface {
	// 호가 이력 조회
	GetOrderbooks(context.Context, *GetOrderbooksRequest) (*GetOrderbooksResponse, error)
	// 최신 호가 조회
	GetLatestOrderbook(context.Context, *GetLatestOrderbookRequest) (*Orderbook, error)
	// 특정 시점 스냅샷
	GetOrderbookSnapshot(context.Context, *GetOrderbookSnapshotRequest) (*Orderbook, error)
	// 실시간 호가 스트림
	SubscribeOrderbooks(*SubscribeRequest, OrderbookService_SubscribeOrderbooksServer) error
	mustEmbedUnimplementedOrderbookServiceServer()
}

// UnimplementedOrderbookServiceServer must be embedded to have forward compatible implementations.
type UnimplementedOrderbookServiceServer struct {
}

func (UnimplementedOrderbookServiceServer) GetOrderbooks(context.Context, *GetOrderbooksRequest) (*GetOrderbooksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrderbooks not implemented")
}
func (UnimplementedOrderbookServiceServer) GetLatestOrderbook(context.Context, *GetLatestOrderbookRequest) (*Orderbook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatestOrderbook not implemented")
}
func (UnimplementedOrderbookServiceServer) GetOrderbookSnapshot(context.Context, *GetOrderbookSnapshotRequest) (*Orderbook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrderbookSnapshot not implemented")
}
func (UnimplementedOrderbookServiceServer) SubscribeOrderbooks(*SubscribeRequest, OrderbookService_SubscribeOrderbooksServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeOrderbooks not implemented")
}
func (UnimplementedOrderbookServiceServer) mustEmbedUnimplementedOrderbookServiceServer() {}

// UnsafeOrderbookServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrderbookServiceServer will
// result in compilation errors.
type UnsafeOrderbookServiceServer interface {
	mustEmbedUnimplementedOrderbookServiceServer()
}

func RegisterOrderbookServiceServer(s grpc.ServiceRegistrar, srv OrderbookServiceServer) {
	s.RegisterService(&OrderbookService_ServiceDesc, srv)
}

func _OrderbookService_GetOrderbooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrderbooksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderbookServiceServer).GetOrderbooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/market_archive.v1.market.OrderbookService/GetOrderbooks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderbookServiceServer).GetOrderbooks(ctx, req.(*GetOrderbooksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderbookService_GetLatestOrderbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestOrderbookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderbookServiceServer).GetLatestOrderbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/market_archive.v1.market.OrderbookService/GetLatestOrderbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderbookServiceServer).GetLatestOrderbook(ctx, req.(*GetLatestOrderbookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderbookService_GetOrderbookSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrderbookSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderbookServiceServer).GetOrderbookSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/market_archive.v1.market.OrderbookService/GetOrderbookSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderbookServiceServer).GetOrderbookSnapshot(ctx, req.(*GetOrderbookSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderbookService_SubscribeOrderbooks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrderbookServiceServer).SubscribeOrderbooks(m, &orderbookServiceSubscribeOrderbooksServer{stream})
}

type OrderbookService_SubscribeOrderbooksServer interface {
	Send(*OrderbookUpdate) error
	grpc.ServerStream
}

type orderbookServiceSubscribeOrderbooksServer struct {
	grpc.ServerStream
}

func (x *orderbookServiceSubscribeOrderbooksServer) Send(m *OrderbookUpdate) error {
	return x.ServerStream.SendMsg(m)
}

// OrderbookService_ServiceDesc is the grpc.ServiceDesc for OrderbookService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrderbookService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "market_archive.v1.market.OrderbookService",
	HandlerType: (*OrderbookServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOrderbooks",
			Handler:    _OrderbookService_GetOrderbooks_Handler,
		},
		{
			MethodName: "GetLatestOrderbook",
			Handler:    _OrderbookService_GetLatestOrderbook_Handler,
		},
		{
			MethodName: "GetOrderbookSnapshot",
			Handler:    _OrderbookService_GetOrderbookSnapshot_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeOrderbooks",
			Handler:       _OrderbookService_SubscribeOrderbooks_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "market_archive/v1/market.proto",
}

// TradeServiceClient is the client API for TradeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TradeServiceClient interface {
	// 체결 이력 조회
	GetTrades(ctx context.Context, in *GetTradesRequest, opts ...grpc.CallOption) (*GetTradesResponse, error)
	// 실시간 체결 스트림
	SubscribeTrades(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (TradeService_SubscribeTradesClient, error)
}

type tradeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTradeServiceClient(cc grpc.ClientConnInterface) TradeServiceClient {
	return &tradeServiceClient{cc}
}

func (c *tradeServiceClient) GetTrades(ctx context.Context, in *GetTradesRequest, opts ...grpc.CallOption) (*GetTradesResponse, error) {
	out := new(GetTradesResponse)
	err := c.cc.Invoke(ctx, "/market_archive.v1.market.TradeService/GetTrades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeServiceClient) SubscribeTrades(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (TradeService_SubscribeTradesClient, error) {
	stream, err := c.cc.NewStream(ctx, &TradeService_ServiceDesc.Streams[0], "/market_archive.v1.market.TradeService/SubscribeTrades", opts...)
	if err != nil {
		return nil, err
	}
	x := &tradeServiceSubscribeTradesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TradeService_SubscribeTradesClient interface {
	Recv() (*TradeUpdate, error)
	grpc.ClientStream
}

type tradeServiceSubscribeTradesClient struct {
	grpc.ClientStream
}

func (x *tradeServiceSubscribeTradesClient) Recv() (*TradeUpdate, error) {
	m := new(TradeUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TradeServiceServer is the server API for TradeService service.
// All implementations must embed UnimplementedTradeServiceServer
// for forward compatibility
type TradeServiceServer interface {
	// 체결 이력 조회
	GetTrades(context.Context, *GetTradesRequest) (*GetTradesResponse, error)
	// 실시간 체결 스트림
	SubscribeTrades(*SubscribeRequest, TradeService_SubscribeTradesServer) error
	mustEmbedUnimplementedTradeServiceServer()
}

// UnimplementedTradeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTradeServiceServer struct {
}

func (UnimplementedTradeServiceServer) GetTrades(context.Context, *GetTradesRequest) (*GetTradesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrades not implemented")
}
func (UnimplementedTradeServiceServer) SubscribeTrades(*SubscribeRequest, TradeService_SubscribeTradesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeTrades not implemented")
}
func (UnimplementedTradeServiceServer) mustEmbedUnimplementedTradeServiceServer() {}

// UnsafeTradeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TradeServiceServer will
// result in compilation errors.
type UnsafeTradeServiceServer interface {
	mustEmbedUnimplementedTradeServiceServer()
}

func RegisterTradeServiceServer(s grpc.ServiceRegistrar, srv TradeServiceServer) {
	s.RegisterService(&TradeService_ServiceDesc, srv)
}

func _TradeService_GetTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServiceServer).GetTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/market_archive.v1.market.TradeService/GetTrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServiceServer).GetTrades(ctx, req.(*GetTradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradeService_SubscribeTrades_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TradeServiceServer).SubscribeTrades(m, &tradeServiceSubscribeTradesServer{stream})
}

type TradeService_SubscribeTradesServer interface {
	Send(*TradeUpdate) error
	grpc.ServerStream
}

type tradeServiceSubscribeTradesServer struct {
	grpc.ServerStream
}

func (x *tradeServiceSubscribeTradesServer) Send(m *TradeUpdate) error {
	return x.ServerStream.SendMsg(m)
}

// TradeService_ServiceDesc is the grpc.ServiceDesc for TradeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TradeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "market_archive.v1.market.TradeService",
	HandlerType: (*TradeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTrades",
			Handler:    _TradeService_GetTrades_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeTrades",
			Handler:       _TradeService_SubscribeTrades_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "market_archive/v1/market.proto",
}

// CandleServiceClient is the client API for CandleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CandleServiceClient interface {
	// OHLC 조회
	GetCandles(ctx context.Context, in *GetCandlesRequest, opts ...grpc.CallOption) (*GetCandlesResponse, error)
	// 실시간 캔들 스트림 (진행중인 캔들 업데이트)
	SubscribeCandles(ctx context.Context, in *GetCandlesRequest, opts ...grpc.CallOption) (CandleService_SubscribeCandlesClient, error)
}

type candleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCandleServiceClient(cc grpc.ClientConnInterface) CandleServiceClient {
	return &candleServiceClient{cc}
}

func (c *candleServiceClient) GetCandles(ctx context.Context, in *GetCandlesRequest, opts ...grpc.CallOption) (*GetCandlesResponse, error) {
	out := new(GetCandlesResponse)
	err := c.cc.Invoke(ctx, "/market_archive.v1.market.CandleService/GetCandles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *candleServiceClient) SubscribeCandles(ctx context.Context, in *GetCandlesRequest, opts ...grpc.CallOption) (CandleService_SubscribeCandlesClient, error) {
	stream, err := c.cc.NewStream(ctx, &CandleService_ServiceDesc.Streams[0], "/market_archive.v1.market.CandleService/SubscribeCandles", opts...)
	if err != nil {
		return nil, err
	}
	x := &candleServiceSubscribeCandlesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CandleService_SubscribeCandlesClient interface {
	Recv() (*Candle, error)
	grpc.ClientStream
}

type candleServiceSubscribeCandlesClient struct {
	grpc.ClientStream
}

func (x *candleServiceSubscribeCandlesClient) Recv() (*Candle, error) {
	m := new(Candle)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CandleServiceServer is the server API for CandleService service.
// All implementations must embed UnimplementedCandleServiceServer
// for forward compatibility
type CandleServiceServer interface {
	// OHLC 조회
	GetCandles(context.Context, *GetCandlesRequest) (*GetCandlesResponse, error)
	// 실시간 캔들 스트림 (진행중인 캔들 업데이트)
	SubscribeCandles(*GetCandlesRequest, CandleService_SubscribeCandlesServer) error
	mustEmbedUnimplementedCandleServiceServer()
}

// UnimplementedCandleServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCandleServiceServer struct {
}

func (UnimplementedCandleServiceServer) GetCandles(context.Context, *GetCandlesRequest) (*GetCandlesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCandles not implemented")
}
func (UnimplementedCandleServiceServer) SubscribeCandles(*GetCandlesRequest, CandleService_SubscribeCandlesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeCandles not implemented")
}
func (UnimplementedCandleServiceServer) mustEmbedUnimplementedCandleServiceServer() {}

// UnsafeCandleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CandleServiceServer will
// result in compilation errors.
type UnsafeCandleServiceServer interface {
	mustEmbedUnimplementedCandleServiceServer()
}

func RegisterCandleServiceServer(s grpc.ServiceRegistrar, srv CandleServiceServer) {
	s.RegisterService(&CandleService_ServiceDesc, srv)
}

func _CandleService_GetCandles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCandlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CandleServiceServer).GetCandles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/market_archive.v1.market.CandleService/GetCandles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CandleServiceServer).GetCandles(ctx, req.(*GetCandlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CandleService_SubscribeCandles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetCandlesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CandleServiceServer).SubscribeCandles(m, &candleServiceSubscribeCandlesServer{stream})
}

type CandleService_SubscribeCandlesServer interface {
	Send(*Candle) error
	grpc.ServerStream
}

type candleServiceSubscribeCandlesServer struct {
	grpc.ServerStream
}

func (x *candleServiceSubscribeCandlesServer) Send(m *Candle) error {
	return x.ServerStream.SendMsg(m)
}

// CandleService_ServiceDesc is the grpc.ServiceDesc for CandleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CandleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "market_archive.v1.market.CandleService",
	HandlerType: (*CandleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCandles",
			Handler:    _CandleService_GetCandles_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeCandles",
			Handler:       _CandleService_SubscribeCandles_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "market_archive/v1/market.proto",
}

// SymbolServiceClient is the client API for SymbolService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SymbolServiceClient interface {
	// 종목 목록
	ListSymbols(ctx context.Context, in *ListSymbolsRequest, opts ...grpc.CallOption) (*ListSymbolsResponse, error)
	// 종목 정보
	GetSymbol(ctx context.Context, in *GetLatestOrderbookRequest, opts ...grpc.CallOption) (*SymbolInfo, error)
}

type symbolServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSymbolServiceClient(cc grpc.ClientConnInterface) SymbolServiceClient {
	return &symbolServiceClient{cc}
}

func (c *symbolServiceClient) ListSymbols(ctx context.Context, in *ListSymbolsRequest, opts ...grpc.CallOption) (*ListSymbolsResponse, error) {
	out := new(ListSymbolsResponse)
	err := c.cc.Invoke(ctx, "/market_archive.v1.market.SymbolService/ListSymbols", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *symbolServiceClient) GetSymbol(ctx context.Context, in *GetLatestOrderbookRequest, opts ...grpc.CallOption) (*SymbolInfo, error) {
	out := new(SymbolInfo)
	err := c.cc.Invoke(ctx, "/market_archive.v1.market.SymbolService/GetSymbol", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SymbolServiceServer is the server API for SymbolService service.
// All implementations must embed UnimplementedSymbolServiceServer
// for forward compatibility
type SymbolServiceServer interface {
	// 종목 목록
	ListSymbols(context.Context, *ListSymbolsRequest) (*ListSymbolsResponse, error)
	// 종목 정보
	GetSymbol(context.Context, *GetLatestOrderbookRequest) (*SymbolInfo, error)
	mustEmbedUnimplementedSymbolServiceServer()
}

// UnimplementedSymbolServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSymbolServiceServer struct {
}

func (UnimplementedSymbolServiceServer) ListSymbols(context.Context, *ListSymbolsRequest) (*ListSymbolsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSymbols not implemented")
}
func (UnimplementedSymbolServiceServer) GetSymbol(context.Context, *GetLatestOrderbookRequest) (*SymbolInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSymbol not implemented")
}
func (UnimplementedSymbolServiceServer) mustEmbedUnimplementedSymbolServiceServer() {}

// UnsafeSymbolServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SymbolServiceServer will
// result in compilation errors.
type UnsafeSymbolServiceServer interface {
	mustEmbedUnimplementedSymbolServiceServer()
}

func RegisterSymbolServiceServer(s grpc.ServiceRegistrar, srv SymbolServiceServer) {
	s.RegisterService(&SymbolService_ServiceDesc, srv)
}

func _SymbolService_ListSymbols_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSymbolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SymbolServiceServer).ListSymbols(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/market_archive.v1.market.SymbolService/ListSymbols",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SymbolServiceServer).ListSymbols(ctx, req.(*ListSymbolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SymbolService_GetSymbol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestOrderbookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SymbolServiceServer).GetSymbol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/market_archive.v1.market.SymbolService/GetSymbol",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SymbolServiceServer).GetSymbol(ctx, req.(*GetLatestOrderbookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SymbolService_ServiceDesc is the grpc.ServiceDesc for SymbolService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SymbolService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "market_archive.v1.market.SymbolService",
	HandlerType: (*SymbolServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListSymbols",
			Handler:    _SymbolService_ListSymbols_Handler,
		},
		{
			MethodName: "GetSymbol",
			Handler:    _SymbolService_GetSymbol_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "market_archive/v1/market.proto",
}

// IndicatorServiceClient is the client API for IndicatorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IndicatorServiceClient interface {
	// 지표 계산 조회
	GetIndicator(ctx context.Context, in *GetIndicatorRequest, opts ...grpc.CallOption) (*GetIndicatorResponse, error)
}

type indicatorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIndicatorServiceClient(cc grpc.ClientConnInterface) IndicatorServiceClient {
	return &indicatorServiceClient{cc}
}

func (c *indicatorServiceClient) GetIndicator(ctx context.Context, in *GetIndicatorRequest, opts ...grpc.CallOption) (*GetIndicatorResponse, error) {
	out := new(GetIndicatorResponse)
	err := c.cc.Invoke(ctx, "/market_archive.v1.market.IndicatorService/GetIndicator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IndicatorServiceServer is the server API for IndicatorService service.
// All implementations must embed UnimplementedIndicatorServiceServer
// for forward compatibility
type IndicatorServiceServer interface {
	// 지표 계산 조회
	GetIndicator(context.Context, *GetIndicatorRequest) (*GetIndicatorResponse, error)
	mustEmbedUnimplementedIndicatorServiceServer()
}

// UnimplementedIndicatorServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIndicatorServiceServer struct {
}

func (UnimplementedIndicatorServiceServer) GetIndicator(context.Context, *GetIndicatorRequest) (*GetIndicatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIndicator not implemented")
}
func (UnimplementedIndicatorServiceServer) mustEmbedUnimplementedIndicatorServiceServer() {}

// UnsafeIndicatorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IndicatorServiceServer will
// result in compilation errors.
type UnsafeIndicatorServiceServer interface {
	mustEmbedUnimplementedIndicatorServiceServer()
}

func RegisterIndicatorServiceServer(s grpc.ServiceRegistrar, srv IndicatorServiceServer) {
	s.RegisterService(&IndicatorService_ServiceDesc, srv)
}

func _IndicatorService_GetIndicator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIndicatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndicatorServiceServer).GetIndicator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/market_archive.v1.market.IndicatorService/GetIndicator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndicatorServiceServer).GetIndicator(ctx, req.(*GetIndicatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IndicatorService_ServiceDesc is the grpc.ServiceDesc for IndicatorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IndicatorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "market_archive.v1.market.IndicatorService",
	HandlerType: (*IndicatorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetIndicator",
			Handler:    _IndicatorService_GetIndicator_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "market_archive/v1/market.proto",
}

// IngestionServiceClient is the client API for IngestionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IngestionServiceClient interface {
	// 단일 파일 적재
	IngestFile(ctx context.Context, in *IngestFileRequest, opts ...grpc.CallOption) (*IngestFileResponse, error)
	// 디렉토리 일괄 적재
	IngestDirectory(ctx context.Context, in *IngestDirectoryRequest, opts ...grpc.CallOption) (*IngestDirectoryResponse, error)
}

type ingestionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIngestionServiceClient(cc grpc.ClientConnInterface) IngestionServiceClient {
	return &ingestionServiceClient{cc}
}

func (c *ingestionServiceClient) IngestFile(ctx context.Context, in *IngestFileRequest, opts ...grpc.CallOption) (*IngestFileResponse, error) {
	out := new(IngestFileResponse)
	err := c.cc.Invoke(ctx, "/market_archive.v1.market.IngestionService/IngestFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ingestionServiceClient) IngestDirectory(ctx context.Context, in *IngestDirectoryRequest, opts ...grpc.CallOption) (*IngestDirectoryResponse, error) {
	out := new(IngestDirectoryResponse)
	err := c.cc.Invoke(ctx, "/market_archive.v1.market.IngestionService/IngestDirectory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IngestionServiceServer is the server API for IngestionService service.
// All implementations must embed UnimplementedIngestionServiceServer
// for forward compatibility
type IngestionServiceServer interface {
	// 단일 파일 적재
	IngestFile(context.Context, *IngestFileRequest) (*IngestFileResponse, error)
	// 디렉토리 일괄 적재
	IngestDirectory(context.Context, *IngestDirectoryRequest) (*IngestDirectoryResponse, error)
	mustEmbedUnimplementedIngestionServiceServer()
}

// UnimplementedIngestionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIngestionServiceServer struct {
}

func (UnimplementedIngestionServiceServer) IngestFile(context.Context, *IngestFileRequest) (*IngestFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IngestFile not implemented")
}
func (UnimplementedIngestionServiceServer) IngestDirectory(context.Context, *IngestDirectoryRequest) (*IngestDirectoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IngestDirectory not implemented")
}
func (UnimplementedIngestionServiceServer) mustEmbedUnimplementedIngestionServiceServer() {}

// UnsafeIngestionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IngestionServiceServer will
// result in compilation errors.
type UnsafeIngestionServiceServer interface {
	mustEmbedUnimplementedIngestionServiceServer()
}

func RegisterIngestionServiceServer(s grpc.ServiceRegistrar, srv IngestionServiceServer) {
	s.RegisterService(&IngestionService_ServiceDesc, srv)
}

func _IngestionService_IngestFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IngestionServiceServer).IngestFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/market_archive.v1.market.IngestionService/IngestFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IngestionServiceServer).IngestFile(ctx, req.(*IngestFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IngestionService_IngestDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestDirectoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IngestionServiceServer).IngestDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/market_archive.v1.market.IngestionService/IngestDirectory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IngestionServiceServer).IngestDirectory(ctx, req.(*IngestDirectoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IngestionService_ServiceDesc is the grpc.ServiceDesc for IngestionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IngestionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "market_archive.v1.market.IngestionService",
	HandlerType: (*IngestionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IngestFile",
			Handler:    _IngestionService_IngestFile_Handler,
		},
		{
			MethodName: "IngestDirectory",
			Handler:    _IngestionService_IngestDirectory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "market_archive/v1/market.proto",
}
