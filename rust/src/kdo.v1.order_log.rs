// @generated
// This file is @generated by prost-build.
/// 주문 로그
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderLog {
    /// 로그 고유 ID (DB에서 자동 생성)
    #[prost(int64, tag="1")]
    pub id: i64,
    /// 주문 ID (거래소에서 받은 ID)
    #[prost(uint64, tag="2")]
    pub order_id: u64,
    /// 원본 주문 ID (수정/취소의 경우)
    /// Option<u64>는 optional uint64로 매핑
    #[prost(uint64, optional, tag="3")]
    pub original_order_id: ::core::option::Option<u64>,
    /// 펀드 코드
    #[prost(string, tag="4")]
    pub fund_code: ::prost::alloc::string::String,
    /// 심볼
    #[prost(string, tag="5")]
    pub symbol: ::prost::alloc::string::String,
    /// 로그 타입
    #[prost(enumeration="OrderLogType", tag="6")]
    pub log_type: i32,
    /// 주문 방향 (매수/매도)
    #[prost(enumeration="OrderSide", tag="7")]
    pub side: i32,
    /// 주문 타입 (신규/정정/취소)
    #[prost(enumeration="OrderType", tag="8")]
    pub order_type: i32,
    /// 주문 가격 (Price)
    /// 정확도 유지를 위해 string 또는 고정 소수점(fixed64 등)을 사용할 수 있으나,
    /// 여기서는 간단하게 string으로 가정
    #[prost(string, tag="9")]
    pub price: ::prost::alloc::string::String,
    /// 주문 수량 (Quantity)
    /// 정확도 유지를 위해 string 또는 고정 소수점(fixed64 등)을 사용할 수 있으나,
    /// 여기서는 간단하게 string으로 가정
    #[prost(string, tag="10")]
    pub quantity: ::prost::alloc::string::String,
    /// 체결 가격 (Filled 로그의 경우) (FilledPrice)
    #[prost(string, optional, tag="11")]
    pub filled_price: ::core::option::Option<::prost::alloc::string::String>,
    /// 체결 수량 (Filled 로그의 경우) (FilledQuantity)
    #[prost(string, optional, tag="12")]
    pub filled_quantity: ::core::option::Option<::prost::alloc::string::String>,
    /// 체결 금액 (계산값) (FilledAmount)
    #[prost(string, optional, tag="13")]
    pub filled_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// 거부/취소 코드
    #[prost(string, optional, tag="14")]
    pub rejection_code: ::core::option::Option<::prost::alloc::string::String>,
    /// 에러 메시지 (MeritzRejected의 경우)
    #[prost(string, optional, tag="15")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// 이벤트 발생 시각 (거래소 시각, 마이크로초)
    /// Rust Timestamp 타입을 u64로 가정
    #[prost(uint64, tag="16")]
    pub event_time: u64,
    /// 이벤트 수신 시각 (시스템 시각, 마이크로초)
    /// Rust Timestamp 타입을 u64로 가정
    #[prost(uint64, tag="17")]
    pub receive_time: u64,
    /// DB 삽입 시각
    /// Rust의 DateTime<Utc> 타입을 Google의 Timestamp 메시지로 매핑
    #[prost(message, optional, tag="18")]
    pub created_at: ::core::option::Option<super::super::super::google::protobuf::Timestamp>,
}
// ========== Request/Response Messages ==========

/// ListOrderLogs 요청
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrderLogsRequest {
    /// 페이지 크기 (optional)
    #[prost(uint32, optional, tag="1")]
    pub page_size: ::core::option::Option<u32>,
    /// 페이지 토큰 (optional, for pagination)
    #[prost(string, optional, tag="2")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    /// Available Sequence and Operator
    /// * fund_code
    ///    * `equal`, `contains`
    /// * symbol
    ///    * `equal`, `contains`
    ///
    /// Examples
    /// * filter=fund_code="0159"
    /// * filter=symbol:"7526"
    #[prost(string, tag="3")]
    pub filter: ::prost::alloc::string::String,
}
/// ListOrderLogs 응답
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrderLogsResponse {
    /// 펀드 목록
    #[prost(message, repeated, tag="1")]
    pub order_logs: ::prost::alloc::vec::Vec<OrderLog>,
    /// 다음 페이지 토큰
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// 주문 로그 타입
///
/// Rust의 SCREAMING_SNAKE_CASE를 반영하여 정의
/// 주석은 Rust 코드의 내용을 번역했습니다.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderLogType {
    /// 알 수 없는 값 (기본값)
    Unspecified = 0,
    /// 접수 확인
    Received = 1,
    /// 거래소 거부
    Rejected = 2,
    /// 메리츠 내부 거부
    MeritzRejected = 3,
    /// 체결
    Filled = 4,
    /// 자동 취소
    AutoCancelled = 5,
}
impl OrderLogType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OrderLogType::Unspecified => "ORDER_LOG_TYPE_UNSPECIFIED",
            OrderLogType::Received => "RECEIVED",
            OrderLogType::Rejected => "REJECTED",
            OrderLogType::MeritzRejected => "MERITZ_REJECTED",
            OrderLogType::Filled => "FILLED",
            OrderLogType::AutoCancelled => "AUTO_CANCELLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDER_LOG_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RECEIVED" => Some(Self::Received),
            "REJECTED" => Some(Self::Rejected),
            "MERITZ_REJECTED" => Some(Self::MeritzRejected),
            "FILLED" => Some(Self::Filled),
            "AUTO_CANCELLED" => Some(Self::AutoCancelled),
            _ => None,
        }
    }
}
/// 주문 방향 (매수/매도)
/// Rust 코드에는 정의되지 않았지만, OrderLog에 사용되므로 정의 가정
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderSide {
    Unspecified = 0,
    /// 매수
    Buy = 1,
    /// 매도
    Sell = 2,
}
impl OrderSide {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OrderSide::Unspecified => "ORDER_SIDE_UNSPECIFIED",
            OrderSide::Buy => "BUY",
            OrderSide::Sell => "SELL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDER_SIDE_UNSPECIFIED" => Some(Self::Unspecified),
            "BUY" => Some(Self::Buy),
            "SELL" => Some(Self::Sell),
            _ => None,
        }
    }
}
/// 주문 타입 (신규/정정/취소)
/// Rust 코드에는 정의되지 않았지만, OrderLog에 사용되므로 정의 가정
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderType {
    Unspecified = 0,
    /// 신규
    New = 1,
    /// 정정
    Amend = 2,
    /// 취소
    Cancel = 3,
}
impl OrderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OrderType::Unspecified => "ORDER_TYPE_UNSPECIFIED",
            OrderType::New => "NEW",
            OrderType::Amend => "AMEND",
            OrderType::Cancel => "CANCEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NEW" => Some(Self::New),
            "AMEND" => Some(Self::Amend),
            "CANCEL" => Some(Self::Cancel),
            _ => None,
        }
    }
}
include!("kdo.v1.order_log.tonic.rs");
include!("kdo.v1.order_log.serde.rs");
// @@protoc_insertion_point(module)