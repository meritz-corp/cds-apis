// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Etf {
    /// ETF ID
    #[prost(uint64, tag="1")]
    pub id: u64,
    /// ETF 심볼 (ISIN 코드)
    #[prost(string, tag="2")]
    pub symbol: ::prost::alloc::string::String,
    /// ETF 이름
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    /// 마지막 가격
    #[prost(string, tag="4")]
    pub last_price: ::prost::alloc::string::String,
    /// PDF 구성 종목 목록
    #[prost(message, repeated, tag="5")]
    pub constituents: ::prost::alloc::vec::Vec<EtfPdfConstituent>,
    /// NAV 정보
    #[prost(message, optional, tag="6")]
    pub nav: ::core::option::Option<EtfNav>,
    /// 설정 단위
    #[prost(int64, tag="8")]
    pub creation_unit: i64,
    /// Tick 크기 (원 단위, i64)
    #[prost(int64, tag="9")]
    pub tick_size: i64,
    /// 복제 방법
    #[prost(enumeration="ReplicationMethod", tag="10")]
    pub replication_method: i32,
}
/// PDF 구성 종목
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtfPdfConstituent {
    /// 종목 코드
    #[prost(string, tag="1")]
    pub code: ::prost::alloc::string::String,
    /// 종목명
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// 상품 타입
    #[prost(enumeration="ProductType", tag="3")]
    pub product_type: i32,
    /// 구성 수량 (선물 숏의 경우 음수)
    #[prost(int64, tag="4")]
    pub quantity: i64,
}
/// ETF NAV 정보
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtfNav {
    #[prost(oneof="etf_nav::NavType", tags="1, 2")]
    pub nav_type: ::core::option::Option<etf_nav::NavType>,
}
/// Nested message and enum types in `EtfNav`.
pub mod etf_nav {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum NavType {
        #[prost(message, tag="1")]
        Physical(super::PhysicalNav),
        #[prost(message, tag="2")]
        FuturesBased(super::FuturesBasedNav),
    }
}
/// 현물 기반 NAV
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhysicalNav {
    /// 마지막 NAV (원 단위, i64)
    #[prost(string, tag="1")]
    pub last_nav: ::prost::alloc::string::String,
    /// 구성종목별 가격 정보
    #[prost(map="string, message", tag="2")]
    pub constituents: ::std::collections::HashMap<::prost::alloc::string::String, ConstituentPrice>,
}
/// 선물 기반 NAV
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FuturesBasedNav {
    /// 마지막 NAV (원 단위, i64)
    #[prost(string, tag="1")]
    pub last_nav: ::prost::alloc::string::String,
    /// 전일 NAV
    #[prost(string, tag="2")]
    pub prior_day_nav: ::prost::alloc::string::String,
    /// 레버리지 배수
    #[prost(double, tag="3")]
    pub leverage_multiplier: f64,
    /// 선물 심볼
    #[prost(string, tag="4")]
    pub futures_symbol: ::prost::alloc::string::String,
    /// 선물 전일 가격
    #[prost(string, tag="5")]
    pub futures_prior_day_price: ::prost::alloc::string::String,
    /// 선물 현재 가격
    #[prost(string, tag="6")]
    pub futures_last_price: ::prost::alloc::string::String,
}
/// 구성종목 가격 정보
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConstituentPrice {
    /// 마지막 가격 (원 단위, i64)
    #[prost(string, tag="1")]
    pub last_price: ::prost::alloc::string::String,
    /// 구성 수량
    #[prost(int64, tag="2")]
    pub quantity: i64,
}
/// ETF LP 설정
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtfLp {
    /// ETF 심볼
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// Fund
    #[prost(string, tag="2")]
    pub fund_code: ::prost::alloc::string::String,
    /// Offset (호가 스프레드 조정, 원 단위, i64)
    #[prost(int64, tag="4")]
    pub bid_offset: i64,
    /// Offset (호가 스프레드 조정, 원 단위, i64)
    #[prost(int64, tag="5")]
    pub ask_offset: i64,
    /// Basis 스프레드 (원 단위, i64)
    #[prost(int64, tag="6")]
    pub basis: i64,
    /// 주문 수량 (i64)
    #[prost(int64, tag="7")]
    pub quantity: i64,
    /// 호가 깊이 (양방향 레벨 수)
    #[prost(uint32, tag="8")]
    pub depth: u32,
    /// ETF tick 크기 (원 단위, i64)
    #[prost(int64, tag="9")]
    pub tick_size: i64,
}
// ========== ETF LP Status Messages ==========

/// ETF LP 상태
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtfLpStatus {
    /// LP 상태
    #[prost(enumeration="EtfLpState", tag="1")]
    pub state: i32,
    /// 시작 시간 (Unix timestamp, seconds)
    #[prost(int64, tag="2")]
    pub start_time: i64,
    /// 주문 통계
    #[prost(message, optional, tag="3")]
    pub order_stats: ::core::option::Option<OrderStats>,
    /// Order Limiter 상태
    #[prost(message, optional, tag="4")]
    pub order_limit: ::core::option::Option<OrderLimitStatus>,
    /// 가격 정보
    #[prost(message, optional, tag="5")]
    pub pricing: ::core::option::Option<LpPricing>,
}
/// 주문 통계
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OrderStats {
    /// 총 전송 주문 수
    #[prost(uint64, tag="1")]
    pub total_orders_sent: u64,
    /// 접수된 주문 수
    #[prost(uint64, tag="2")]
    pub orders_accepted: u64,
    /// 거부된 주문 수
    #[prost(uint64, tag="3")]
    pub orders_rejected: u64,
    /// 체결된 주문 수
    #[prost(uint64, tag="4")]
    pub orders_filled: u64,
    /// 총 체결 수량
    #[prost(int64, tag="5")]
    pub total_filled_quantity: i64,
    /// 일일 체결 수량
    #[prost(int64, tag="6")]
    pub daily_filled_quantity: i64,
}
/// Order Limiter 상태
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderLimitStatus {
    /// 일일 누적 체결 수량 (i64)
    #[prost(int64, tag="1")]
    pub daily_filled_quantity: i64,
    /// 일일 누적 체결 수량 한도 (i64)
    #[prost(int64, tag="2")]
    pub daily_cumulative_limit: i64,
    /// 시간 프레임별 주문 개수 현황
    #[prost(message, repeated, tag="3")]
    pub time_frame_status: ::prost::alloc::vec::Vec<TimeFrameStatus>,
    /// 일일 사용률 (%)
    #[prost(double, tag="4")]
    pub daily_usage_percent: f64,
}
/// 시간 프레임별 상태
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeFrameStatus {
    /// 시간 윈도우 (초)
    #[prost(uint64, tag="1")]
    pub window_seconds: u64,
    /// 현재 윈도우 내 주문 개수
    #[prost(uint32, tag="2")]
    pub current_count: u32,
    /// 최대 주문 개수
    #[prost(uint32, tag="3")]
    pub max_orders: u32,
    /// 사용률 (%)
    #[prost(double, tag="4")]
    pub usage_percent: f64,
}
/// LP 가격 정보
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LpPricing {
    /// ETF 가격 (원 단위, i64)
    #[prost(string, tag="1")]
    pub etf_price: ::prost::alloc::string::String,
    /// 선물 가격 (원 단위, i64)
    #[prost(string, tag="2")]
    pub future_price: ::prost::alloc::string::String,
    /// ETF NAV (원 단위, i64)
    #[prost(string, tag="3")]
    pub etf_nav: ::prost::alloc::string::String,
}
/// ========== Request/Response Messages ==========
/// GetEtfLp
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEtfLpRequest {
    #[prost(string, tag="1")]
    pub etf: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub fund: ::prost::alloc::string::String,
}
/// UpdateEtfLp
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEtfLpRequest {
    #[prost(message, optional, tag="1")]
    pub lp: ::core::option::Option<EtfLp>,
    #[prost(message, optional, tag="2")]
    pub update_mask: ::core::option::Option<super::super::super::google::protobuf::FieldMask>,
}
/// GetEtfLpStatus
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEtfLpStatusRequest {
    #[prost(string, tag="1")]
    pub etf: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub fund: ::prost::alloc::string::String,
}
/// StreamEtfLpStatus
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamEtfLpStatusRequest {
    #[prost(string, tag="1")]
    pub etf: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub fund: ::prost::alloc::string::String,
    /// 업데이트 간격 (초, optional, default: 1)
    #[prost(uint32, optional, tag="3")]
    pub update_interval_seconds: ::core::option::Option<u32>,
}
/// ETF LP 시작 요청
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartEtfLpRequest {
    #[prost(string, tag="1")]
    pub etf: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub fund: ::prost::alloc::string::String,
}
/// ETF LP 시작 응답
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartEtfLpResponse {
    /// LP 상태
    #[prost(message, optional, tag="1")]
    pub status: ::core::option::Option<EtfLpStatus>,
    /// 메시지
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
}
/// ETF LP 중지 요청
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopEtfLpRequest {
    #[prost(string, tag="1")]
    pub etf: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub fund: ::prost::alloc::string::String,
}
/// ETF LP 중지 응답
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopEtfLpResponse {
    /// LP 상태
    #[prost(message, optional, tag="1")]
    pub status: ::core::option::Option<EtfLpStatus>,
    /// 메시지
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
}
/// StreamEtfErrors 요청
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamEtfErrorsRequest {
    #[prost(string, tag="1")]
    pub etf: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub fund: ::prost::alloc::string::String,
}
/// ETF LP 에러 이벤트
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtfLpError {
    /// ETF 심볼
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// 스레드 타입
    #[prost(enumeration="ThreadType", tag="2")]
    pub thread_type: i32,
    /// 에러 타입
    #[prost(enumeration="ErrorType", tag="3")]
    pub error_type: i32,
    /// 에러 메시지
    #[prost(string, tag="4")]
    pub error_message: ::prost::alloc::string::String,
    /// 에러 발생 시간
    #[prost(message, optional, tag="5")]
    pub timestamp: ::core::option::Option<super::super::super::google::protobuf::Timestamp>,
    /// 에러 레벨
    #[prost(enumeration="ErrorLevel", tag="6")]
    pub error_level: i32,
}
/// 주문 업데이트 스트리밍 요청
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserOrderBookRequest {
    #[prost(string, tag="1")]
    pub etf: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub fund: ::prost::alloc::string::String,
}
/// 주문 업데이트 정보
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserOrderbookData {
    /// 매수 호가 (10단계, AIP-144)
    #[prost(string, repeated, tag="1")]
    pub bid_prices: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// 매도 호가 (10단계)
    #[prost(string, repeated, tag="2")]
    pub ask_prices: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// 매수 수량 (10단계)
    #[prost(int64, repeated, tag="3")]
    pub bid_quantities: ::prost::alloc::vec::Vec<i64>,
    /// 매도 수량 (10단계)
    #[prost(int64, repeated, tag="4")]
    pub ask_quantities: ::prost::alloc::vec::Vec<i64>,
}
/// 상품 타입
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProductType {
    Unspecified = 0,
    Stock = 1,
    Futures = 2,
    Etf = 3,
}
impl ProductType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProductType::Unspecified => "PRODUCT_TYPE_UNSPECIFIED",
            ProductType::Stock => "PRODUCT_TYPE_STOCK",
            ProductType::Futures => "PRODUCT_TYPE_FUTURES",
            ProductType::Etf => "PRODUCT_TYPE_ETF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRODUCT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PRODUCT_TYPE_STOCK" => Some(Self::Stock),
            "PRODUCT_TYPE_FUTURES" => Some(Self::Futures),
            "PRODUCT_TYPE_ETF" => Some(Self::Etf),
            _ => None,
        }
    }
}
/// 복제 방법
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReplicationMethod {
    Unspecified = 0,
    Physical = 1,
    Synthetic = 2,
    FuturesBased = 3,
}
impl ReplicationMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ReplicationMethod::Unspecified => "REPLICATION_METHOD_UNSPECIFIED",
            ReplicationMethod::Physical => "REPLICATION_METHOD_PHYSICAL",
            ReplicationMethod::Synthetic => "REPLICATION_METHOD_SYNTHETIC",
            ReplicationMethod::FuturesBased => "REPLICATION_METHOD_FUTURES_BASED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPLICATION_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
            "REPLICATION_METHOD_PHYSICAL" => Some(Self::Physical),
            "REPLICATION_METHOD_SYNTHETIC" => Some(Self::Synthetic),
            "REPLICATION_METHOD_FUTURES_BASED" => Some(Self::FuturesBased),
            _ => None,
        }
    }
}
/// ETF LP 상태 enum
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EtfLpState {
    Unspecified = 0,
    Idle = 1,
    Running = 2,
    Stopping = 3,
    Error = 4,
}
impl EtfLpState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EtfLpState::Unspecified => "ETF_LP_STATE_UNSPECIFIED",
            EtfLpState::Idle => "ETF_LP_STATE_IDLE",
            EtfLpState::Running => "ETF_LP_STATE_RUNNING",
            EtfLpState::Stopping => "ETF_LP_STATE_STOPPING",
            EtfLpState::Error => "ETF_LP_STATE_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ETF_LP_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "ETF_LP_STATE_IDLE" => Some(Self::Idle),
            "ETF_LP_STATE_RUNNING" => Some(Self::Running),
            "ETF_LP_STATE_STOPPING" => Some(Self::Stopping),
            "ETF_LP_STATE_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// 스레드 타입
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThreadType {
    Unspecified = 0,
    Quote = 1,
    Hedge = 2,
}
impl ThreadType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ThreadType::Unspecified => "THREAD_TYPE_UNSPECIFIED",
            ThreadType::Quote => "THREAD_TYPE_QUOTE",
            ThreadType::Hedge => "THREAD_TYPE_HEDGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "THREAD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "THREAD_TYPE_QUOTE" => Some(Self::Quote),
            "THREAD_TYPE_HEDGE" => Some(Self::Hedge),
            _ => None,
        }
    }
}
/// 에러 타입
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorType {
    Unspecified = 0,
    /// 초기화 실패
    Initialization = 1,
    /// 가격 업데이트 실패
    PriceUpdate = 2,
    /// 주문 제출 실패
    OrderSubmit = 3,
    /// 주문 처리 실패
    OrderProcessing = 4,
    /// NAV 계산 실패
    NavCalculation = 5,
    /// 오더북 업데이트 실패
    OrderBookUpdate = 6,
    /// 주문 한도 초과
    LimitExceeded = 7,
    /// 시스템 에러
    SystemError = 8,
}
impl ErrorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ErrorType::Unspecified => "ERROR_TYPE_UNSPECIFIED",
            ErrorType::Initialization => "ERROR_TYPE_INITIALIZATION",
            ErrorType::PriceUpdate => "ERROR_TYPE_PRICE_UPDATE",
            ErrorType::OrderSubmit => "ERROR_TYPE_ORDER_SUBMIT",
            ErrorType::OrderProcessing => "ERROR_TYPE_ORDER_PROCESSING",
            ErrorType::NavCalculation => "ERROR_TYPE_NAV_CALCULATION",
            ErrorType::OrderBookUpdate => "ERROR_TYPE_ORDER_BOOK_UPDATE",
            ErrorType::LimitExceeded => "ERROR_TYPE_LIMIT_EXCEEDED",
            ErrorType::SystemError => "ERROR_TYPE_SYSTEM_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR_TYPE_INITIALIZATION" => Some(Self::Initialization),
            "ERROR_TYPE_PRICE_UPDATE" => Some(Self::PriceUpdate),
            "ERROR_TYPE_ORDER_SUBMIT" => Some(Self::OrderSubmit),
            "ERROR_TYPE_ORDER_PROCESSING" => Some(Self::OrderProcessing),
            "ERROR_TYPE_NAV_CALCULATION" => Some(Self::NavCalculation),
            "ERROR_TYPE_ORDER_BOOK_UPDATE" => Some(Self::OrderBookUpdate),
            "ERROR_TYPE_LIMIT_EXCEEDED" => Some(Self::LimitExceeded),
            "ERROR_TYPE_SYSTEM_ERROR" => Some(Self::SystemError),
            _ => None,
        }
    }
}
/// 에러 레벨
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorLevel {
    Unspecified = 0,
    /// 디버그 정보
    Debug = 1,
    /// 정보성 메시지
    Info = 2,
    /// 경고
    Warning = 3,
    /// 에러
    Error = 4,
    /// 치명적 에러
    Critical = 5,
}
impl ErrorLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ErrorLevel::Unspecified => "ERROR_LEVEL_UNSPECIFIED",
            ErrorLevel::Debug => "ERROR_LEVEL_DEBUG",
            ErrorLevel::Info => "ERROR_LEVEL_INFO",
            ErrorLevel::Warning => "ERROR_LEVEL_WARNING",
            ErrorLevel::Error => "ERROR_LEVEL_ERROR",
            ErrorLevel::Critical => "ERROR_LEVEL_CRITICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR_LEVEL_DEBUG" => Some(Self::Debug),
            "ERROR_LEVEL_INFO" => Some(Self::Info),
            "ERROR_LEVEL_WARNING" => Some(Self::Warning),
            "ERROR_LEVEL_ERROR" => Some(Self::Error),
            "ERROR_LEVEL_CRITICAL" => Some(Self::Critical),
            _ => None,
        }
    }
}
include!("kdo.v1.lp.tonic.rs");
include!("kdo.v1.lp.serde.rs");
// @@protoc_insertion_point(module)