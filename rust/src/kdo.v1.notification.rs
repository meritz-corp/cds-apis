// @generated
// This file is @generated by prost-build.
/// Request message for ListNotifications
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotificationsRequest {
    /// The resource name of User.
    /// Format: users/{user_id}
    #[prost(string, tag="1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of items to return.
    /// If unspecified, at most 50 rows will be returned.
    /// The maximum value is 1024; values above 1024 will be coerced to 1024.
    #[prost(int32, tag="2")]
    pub page_size: i32,
    /// Token of the page to retrieve.
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
    /// Filter expression.
    /// Available filters:
    /// * state: CREATED, ACKNOWLEDGED, EXPIRED
    /// * type: INFO, ERROR
    ///
    /// Examples:
    /// * state=CREATED
    /// * type=INFO
    #[prost(string, tag="4")]
    pub filter: ::prost::alloc::string::String,
}
/// Response message for ListNotifications
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotificationsResponse {
    #[prost(message, repeated, tag="1")]
    pub notifications: ::prost::alloc::vec::Vec<Notification>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for SubscribeNotifications
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeNotificationsRequest {
    /// The resource name of User.
    /// Format: users/{user_id}
    #[prost(string, tag="1")]
    pub parent: ::prost::alloc::string::String,
}
/// Request message for AcknowledgeNotification
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcknowledgeNotificationRequest {
    /// The resource name of the notification.
    /// Format: users/{user_id}/notifications/{notification_id}
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
/// Action to perform when notification is clicked
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationAction {
    /// Type of action
    #[prost(oneof="notification_action::Action", tags="1, 2")]
    pub action: ::core::option::Option<notification_action::Action>,
}
/// Nested message and enum types in `NotificationAction`.
pub mod notification_action {
    /// Type of action
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        /// No operation
        #[prost(message, tag="1")]
        NoOp(super::NoOp),
        /// Navigate to a page
        #[prost(message, tag="2")]
        Navigate(super::NavigateAction),
    }
}
/// No operation action
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NoOp {
}
/// Navigation action
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NavigateAction {
    /// Navigation target
    #[prost(oneof="navigate_action::Target", tags="1")]
    pub target: ::core::option::Option<navigate_action::Target>,
}
/// Nested message and enum types in `NavigateAction`.
pub mod navigate_action {
    /// Navigation target
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        /// Navigate to LP page
        ///
        /// Future targets can be added here:
        /// OrderDetailTarget order_detail = 2;
        /// SettingsTarget settings = 3;
        #[prost(message, tag="1")]
        LpPage(super::LpPageTarget),
    }
}
/// LP page navigation target
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LpPageTarget {
    /// ETF code (e.g., "A252670")
    #[prost(string, tag="1")]
    pub etf_code: ::prost::alloc::string::String,
    /// Fund code (e.g., "0331")
    #[prost(string, tag="2")]
    pub fund_code: ::prost::alloc::string::String,
}
/// Notification resource
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Notification {
    /// The resource name of the Notification.
    /// Format: users/{user_id}/notifications/{notification_id}
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// The resource name of User.
    /// Format: users/{user_id}
    #[prost(string, tag="2")]
    pub user: ::prost::alloc::string::String,
    /// The id of Notification.
    #[prost(uint64, tag="3")]
    pub id: u64,
    /// Notification type
    #[prost(enumeration="NotificationType", tag="4")]
    pub r#type: i32,
    /// Action to perform when clicked
    #[prost(message, optional, tag="5")]
    pub action: ::core::option::Option<NotificationAction>,
    /// Current state
    #[prost(enumeration="NotificationState", tag="6")]
    pub state: i32,
    /// Notification title
    #[prost(string, tag="7")]
    pub title: ::prost::alloc::string::String,
    /// Notification body
    #[prost(string, tag="8")]
    pub body: ::prost::alloc::string::String,
    /// Additional metadata
    #[prost(map="string, string", tag="9")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Pre-computed navigation URL (convenience field)
    /// e.g., "/lp/A252670"
    #[prost(string, optional, tag="10")]
    pub navigation_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Created timestamp
    #[prost(message, optional, tag="11")]
    pub create_time: ::core::option::Option<super::super::super::google::protobuf::Timestamp>,
    /// Expiration timestamp (if applicable)
    #[prost(message, optional, tag="12")]
    pub expire_time: ::core::option::Option<super::super::super::google::protobuf::Timestamp>,
    /// Acknowledged timestamp
    #[prost(message, optional, tag="13")]
    pub acknowledge_time: ::core::option::Option<super::super::super::google::protobuf::Timestamp>,
}
/// Type of the notification
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NotificationType {
    TypeUnspecified = 0,
    /// Informational notification
    Info = 1,
    /// Error notification
    Error = 2,
}
impl NotificationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NotificationType::TypeUnspecified => "TYPE_UNSPECIFIED",
            NotificationType::Info => "INFO",
            NotificationType::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TYPE_UNSPECIFIED" => Some(Self::TypeUnspecified),
            "INFO" => Some(Self::Info),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// State of the notification
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NotificationState {
    StateUnspecified = 0,
    /// Notification has been created
    Created = 1,
    /// Notification has been acknowledged by user
    Acknowledged = 2,
    /// Notification has expired
    Expired = 3,
}
impl NotificationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NotificationState::StateUnspecified => "STATE_UNSPECIFIED",
            NotificationState::Created => "CREATED",
            NotificationState::Acknowledged => "ACKNOWLEDGED",
            NotificationState::Expired => "EXPIRED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::StateUnspecified),
            "CREATED" => Some(Self::Created),
            "ACKNOWLEDGED" => Some(Self::Acknowledged),
            "EXPIRED" => Some(Self::Expired),
            _ => None,
        }
    }
}
include!("kdo.v1.notification.tonic.rs");
include!("kdo.v1.notification.serde.rs");
// @@protoc_insertion_point(module)